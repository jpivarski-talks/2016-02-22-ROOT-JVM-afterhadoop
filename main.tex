\documentclass{beamer}

\mode<presentation>
{
  \usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[frame number]
} 

\hypersetup{colorlinks=true, urlcolor=blue}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{dirtree}
\usepackage{listings}
\usepackage{courier}

\title[2016-02-22-ROOT-JVM-afterhadoop]{Accessing ROOT from the JVM (update)}
\author{Jim Pivarski}
\date{2016-02-22}

\xdefinecolor{darkblue}{rgb}{0.1,0.1,0.7}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\ttfamily\scriptsize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Uncomment these lines for an automatically generated outline.
%\begin{frame}{Outline}
%  \tableofcontents
%\end{frame}

\begin{frame}{Motivation (reminder)}
\begin{block}{}
\vspace{-\baselineskip}
Data pipeline tools (such as Apache Hadoop, Spark, Storm, etc.) run on the Java Virtual Machine (JVM) and most physics data is in ROOT, so we need a bridge.
\end{block}

\begin{block}{}
\vspace{-\baselineskip}
Target use-case: help physics groups move their TTree skimming jobs to Spark.
\begin{itemize}
\item Potentially faster for iterative studies (skim, fix bug, reskim) because intermediate datasets can be cached in-memory.
\item Abstracts away file locations and transfers, focuses on data transformations.
\item Consolidates many ad-hoc shell scripts into a single, programmable workflow.
\item Tree of {\tt map/filter/reduce} transformations can simplify scanning (parameter scans, cut scans, \ldots).
\item May require training to help physicists adopt the new paradigm, so limit scope to skimming for now.
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Following two approaches:}
\begin{itemize}
\item<1-> {\bf FreeHEP-ROOTIO} (pure-Java reimplementation)
\begin{itemize}
\item Never heard back from Tony Johnson.
\item But it works: never had any problems opening ROOT files (even old ones), and TTree interface is good.
\item However, {\tt RootFileReader} requires a file on disk, which limits usefulness.
\begin{itemize}
\item No {\tt java.io.InputStream} constructor because of seeking.
\item {\tt java.net.URL} constructor doesn't accept ``{\tt http://}''???
\end{itemize}
\end{itemize}

\item<2> Bridge to native ROOT libraries
\begin{itemize}
\item Java's built-in {\bf JNI} requires some care (always failed for me).
\item {\bf JNA} library works pretty well.
\begin{itemize}
\item Must be adapted with intermediate C code to provide a C-like interface.
\item Intermediate {\tt .so} file {\it can} be included in the deployed JAR.
\item Segmentation faults rarely (and randomly). Haven't been able to find cause: outside my code, I don't delete anything.
\end{itemize}
\item Newer {\bf BridJ} library might help:
\begin{itemize}
\item Intended for C++, maybe no need for intermediates.
\item Richer interface for dealing with pointers; optimized for speed.
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Status}

\begin{block}{}
\vspace{-\baselineskip}
I have working code, but I'm rapidly swapping it out as I try new things. New {\tt scaroot} git branch for each major change.
\end{block}

\begin{itemize}
\item Built clean, fast Scala interface to TTrees using compile-time macros (next page).
\item Successfully passed TTrees through Hadoop map-reduce.
\item Successfully passed TTrees through a Spark workflow.
\end{itemize}

{\it However,}
\begin{itemize}
\item Hadoop mappers had to copy the file from HDFS to local disk before reading (fixable).
\item Spark could only use the user's classes if precompiled in a JAR, not given on the commandline, dramatically changing the Spark user experience (fixable).
\item Also, Spark's Kryo serialization had to be used (not a problem: it's 10 times faster than native Java serialization).
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Scala interface}
User has to know the names and types of leaves in the TTree to define an interface. Otherwise, it can't be a first-class object with precompiled field accessors.

\vspace{0.5\baselineskip}
Interface could be auto-generated from a sample ROOT file and pasted into a user's project.

\begin{lstlisting}[language=scala]
case class Dimuon(mass: Float, px: Float, py: Float, pz: Float)
\end{lstlisting}

\begin{onlyenv}<2->
\vspace{-0.35 cm}
\begin{lstlisting}[language=scala]
{
  def momentum = Math.sqrt(px*px + py*py + pz*pz)
  def energy = Math.sqrt(mass*mass + momentum*momentum)
}
\end{lstlisting}
\end{onlyenv}

Scala case classes:
\begin{itemize}
\item are immutable, lightweight data objects;
\item present public fields for each constructor argument;
\item have a readable commandline representation;
\item can be used in pattern-matching for declarative condition checking;
\item are a common currency for Scala data transformation.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Scala interface}

Complete example:

\begin{lstlisting}[language=scala]
case class Dimuon(mass: Float, px: Float, py: Float, pz: Float)
{
  def momentum = Math.sqrt(px*px + py*py + pz*pz)
  def energy = Math.sqrt(mass*mass + momentum*momentum)
}
\end{lstlisting}

Random access readers (iterators are similar):

\begin{lstlisting}[language=scala]
val dimuons1 = FreeHepRootTTreeReader[Dimuon](
  "TrackResonanceNtuple.root", "TrackResonanceNtuple/twoMuon")

val dimuons2 = NativeRootTTreeReader[Dimuon](
  "TrackResonanceNtuple.root", "TrackResonanceNtuple/twoMuon")
\end{lstlisting}

The template resolution ({\tt [Dimuon]} in Scala means {\tt <Dimuon>} in Java/C++) calls a macro that creates a custom factory for the user's {\tt Dimuon} class.

\vspace{0.5\baselineskip}
Alternatives in JVM are:
\begin{itemize}
\item runtime reflection (slower),
\item putting all user operations in a sublanguage (like {\tt TTree::Draw} strings),
\item requiring the user to set up boilerplate.
\end{itemize}
\end{frame}


\end{document}
